#########################################################
#
# PGSTE
#
#  90 - gradient - delay - 180 - delay - gradient - acq
#
# Copyright (c) Magritek Ltd 2023
#
# U.I. V5
#########################################################

#########################################################
#
# The is the entry point for the SpinsolveExpert
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated
#
#########################################################

procedure(PGSTE, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)
   ppGroup = getbasedir(parentPath)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"PGSTE")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("PGSTE")
   else
      gExpt->addExperiment(ppGroup,"PGSTE",parameters)
   endif

endproc()

#########################################################
#
# Provide a backdoor interface to this macro. This
# adds ["nGrad"] to the user interface list (guipar)
# and also generates the pulse program lists required
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
#
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated
#
#########################################################

procedure(getseqpar)

   rel = ["nPnts                = nrPnts",
          "a90H                 = 90Amplitude1H",
          "aOff                 = -85",
          "dFlip1               = 4*pulseLength1H*(flipAngle1/360)",
          "dFlip2               = 4*pulseLength1H*(flipAngle2/360)",
          "dFlip3               = 4*pulseLength1H*(flipAngle3/360)",
          "dStab                = gradStab*1000",
          "nRamp                = 10",
          "dRampStep            = 10",
          "dSmDelta             = 1000*lDelta",
          "acqShift             = PGSTE_pp:getAcqShift(dwellTime)",
          "dAcq                 = dStab+pgo-rxLat+acqShift",
          "dSpoil               = 1000*durSpoil",
          "wBgDelta             = 1000*bDelta-dStab-2000*gradRamp-dSmDelta-dSpoil-2*dFlip1-2*dFlip2-2*dFlip3-6*5",
          "(digGradAmp,gradAmp) = PGSTE_pp:getGradients(gradAmpPC,oshim)",
          "nGradShim            = 0",
          "nGrad                = digGradAmp",
          "nXShim               = xshim",
          "nXSpoil              = xshim-(gSpoil*xshim/(abs(xshim)+0.1))",
          "O1                   = offFreq",
          "totPnts              = nrPnts",
          "totTime              = acqTime"]
   var = ["nGrad"]
   pp_list = ["ndummyGrads","l1","aOff","p3","dFlip1","p4","dFlip2","dFlip3","nGradShim","nGrad","dSmDelta","dStab","nXSpoil","dSpoil","nXShim","wBgDelta","a90H","p1","p2","p5","p6","dAcq","nPnts"]
   pp_name = "PGSTE.p"
   phase_list = [0,2,1,3;2,0,3,1;0,0,0,0;2,2,2,2;0,0,0,0;2,2,2,2;2,0,1,3]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)


#######################################################
# Execute the pulse program, collecting nrScans of
# data and displaying the result in the 1D plot.
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)

# Check for valid gradient ramp
   if(dRampStep < 2)
       pr("Ramp step too short. Increase Gradient ramp time or decrease number of ramp steps.\n")
       return(0)
   endif

# Calculate suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000 # ms
   fAxis = ([0:1:zf*totPnts-1]-zf*totPnts/2)/totTime/zf*1000 # Hz

# Time domain filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTFid",tAxis/1e6)
   else
      flt = matrix(totPnts)+1
   endif

# Get plot regions
   (prt,prf,prs,pri) = ucsPlot:getPlotReferences()
   prt->showimag("true")
   prf->showimag("false")

# Check the integration range
   if(size(intRange) != 2)
      message("Error","Integration range parameter should have two values","error")
      return(0)
   endif
   if(intRange[0] > intRange[1])
      message("Error","Integration range parameter is reversed","error")
      return(0)
   endif

# First order phase correction
   guipar = guipar + ["firstOrderCorr = 0"]
   guipar = guipar + ["normalize = \"yes\""]

# Work out frequency axis scale, label and range
   (fAxisDisp,fAxisLabel,fRange) = ucsPlot:generate1DFrequencyAxis(prf, fAxis, b1Freq1H, wvPPMOffset1H, offFreq, guipar)

# Allocate memory for output data
   ampAxis      = cmatrix(nrSteps)
   gradValueDig = matrix(nrSteps)
   gradValue    = matrix(nrSteps)
   echoInt      = matrix(nrSteps)
   sumData2D    = cmatrix(totPnts, nrSteps)

# Generate the gradient values
   for(gStep = 0 to nrSteps-1)
      gradValueDig[gStep] = (sqrt(gStep+0.2))*(digGradAmp+oshim)/(sqrt(nrSteps-0.8))
      gradValue[gStep]   =  (sqrt(gStep+0.2))*(gradAmp/1000)/(sqrt(nrSteps-0.8))
   next(gStep)

   :saveGradients(gradValue, guipar)

# Parameters to be shared with post processing macros
   IntegrateRegionsPGSE:initSharedData(fAxisDisp,nrPnts*zf,nrSteps,gradValue,bDelta,lDelta,gradRamp,intRange)

   pc = 1 # Phase correction
   ph = 0

# Loop over the gradient steps
   for(gStep = -dummyCycles to nrSteps-1)

      if (gStep < 0)
        gdiff = gradValueDig[0]
      else
        gdiff = gradValueDig[gStep]
      endif
      ppList = ucsRun:setPPNumber(ppList,varIndex[0],gdiff)

      sumData = cmatrix(totPnts)

      # Accumulate scans
      for(scan = 0 to nrScans-1)

         # Update the parameters, check the timing, run the sequence and return the data
         (data,pAcq,status) = ucsRun:runSequence(guipar,ppList,pcList,pcIndex,scan)

         # See if the abort button has been pressed
         if(status == "abort")
            return(0)
         endif

         # Accumlate the data
         sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)
         (phasedTimeData, spectrum) = ucsRun:transformData(zerofill(sumData.*flt,zf*totPnts,"end"),fAxis,guipar,"fid")

         # Plot the time and frequency domain data
         if(gStep < 0)
            titleTxt = "Dummy scan = $(dummyCycles+gStep)*nrScans+scan+1$/$dummyCycles*nrScans$"
         else
            titleTxt = "Gradient step = $gStep+1$, Scan = $scan+1$/$nrScans$"
         endif
         ucsPlot:graphTimeAndFreq(prt,prf,tAxis,sumData,fAxisDisp,spectrum*pc,scan,guipar,
                                  titleTxt,"Spectrum",
                                  "Time (ms)","Amplitude (\G(m)V)",
                                  fAxisLabel,"Amplitude (\G(m)V/Hz)")

       # Check if complete button pressed
         if(status == "finish")
            scan = scan+1
            exitfor()
         endif

      next(scan)

      # Determine phase correction
      if(gStep == 0)
         if(autoPhase == "yes")
            ph = autoPhase1D(spectrum,5)
            try # Update the receiver phase
               n = findobj(0,"name","rxPhase")
               newPhase = (eval(getpar(0,n,"text"))+ph)%360
               setpar(0,n,"text",newPhase)
            catch; endtry;
            pc = exp(i*ph/180*pi)
         else
            ph = 0
            pc = 1
         endif
      endif

      if(gStep > -1)

         # Simple offset baseline correction
         spectrum = ucsRun:baselineCorrection(spectrum*pc,"offset",32)

       # Save the FIDs in a 2D matrix for later processing
         sumData2D[~,gStep] = sumData

       # Save the spectra
         gShared->spec2d[~,gStep] = spectrum

       # Plot the spectra
         StackedPlot(prs,  gShared->spec2d, gStep, fRange, fAxisDisp, "yes", [1,nrSteps],
                            "linear", fAxisLabel, "Gradient step", "Diffusion spectra")


       # Plot the integrals with a fit. Shared parameters allow for dynamic integral selection
         gShared->integralStep = gStep
         IntegrateRegionsPGSE:drawIntegrals(prs,pri,"PGSTE")

      endif

      if(status == "finish")
         exitfor()
      endif

   next(gStep)

# Save the data
   ucsFiles:savePlot(prs,:getPlotInfo("pt3"),guipar,"noReport")
   ucsFiles:savePlot(pri,:getPlotInfo("pt4"),guipar,"noReport")
   ucsFiles:saveMNovaData(sumData2D,"data.2d",guipar,"simpleReport",ph)
   :saveResult(pri, guipar)

# Allow later processing
   :saveGradients(gradValue, guipar)
   :convert2Dosy(sumData2D, guipar)

# Pack the data into a structure
   result = struct()
   result->mTime     = sumData2D/scan
   result->mTimeAxes = [tAxis[0]/1e6,1,nrSteps]
   result->mFreq     = gShared->spec2d/scan
   result->mFreqAxes = [fAxis[0],fAxis[-1],1,nrSteps]

# Remove the shared variable
   rmvar("gShared")

# Return result
   return(result)

endproc("execpp")

procedure(saveResult, plt, guipar)

   assignlist(guipar)

   bak = getcwd()

   cd(dataDirectory) # From guipar
   cd(expName) # From guipar

   (x,y) = plt->getdata()
   export1dpar("ab","ascii","xyrc","xydata")
   export1d(x, y,"pgste.dat")

   cd(bak)

endproc()

########################################################
# Return expected experiment duration in seconds
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = (nrSteps+dummyCycles)*nrScans + useStartDelay
   duration = (totScans*repTime)/1000

endproc(duration)

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt3","DiffusionSpectrumStacked.pt1","pt4","DiffusionPlot.pt1","im1","PGSEData.pt2"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)

########################################################
# Save files suitable for use with the DOSY-toolbox
########################################################

procedure(convert2Dosy, fid2d, guipar)

# Extract GUI parameters
   assignlist(guipar)
   dosyFileName = expName
   ppmOffset = 4.74
   lDeltaCorr = lDelta + gradRamp

# Save data and plot in chosen folder
   bak = getcwd()

   cd(dataDirectory)
   cd(expName)

   # here the conversion to DOSY toolbox format happens
   # Toolbox uses 64 bit integers, so we need to fiddle a bit to get the right format
   fidreal = 1.0*round(1e6*real(fid2d))                        # Scale up, round and convert back to float
   fidimag = 1.0*round(1e6*imag(fid2d))
   fidall  = join(fidreal, fidimag, "horiz")                   # first half of matrix is real, second half is imaginary
   fidallc  = (fidall>=0)-1+i*join(fidreal, fidimag, "horiz")  # Set the first 32 bits to zero if value is positive, -1 if value is negative. Converting to complex makes it simple for programming
   fidall = fidallc

   # write binary data file
   export2dpar("ab", "binary",  "xyrc", "complex",
              "fls", "long", "machine", "bigend",
              "fileheader", 0)
   tempfilename = dosyFileName +".bin"
   export2d(fidall, tempfilename)

   # write ASCII header file
   tempfilename = dosyFileName +".txt"
   printtofile(tempfilename)
   print("## PGSTE Toolbox data file\n")
   print("## ************ File and Data Information **********************\n")
   print("#Binary File Name (string)\n")
   print("*.bin\n")
   print("#Data Class (string) 						 \"FID\"\n")
   print("#Complex Data (string)						 \"Yes\"\n")
   print("#Data Origin (string) 						 \"DOSY Toolbox\"\n")
   print("#Data Type (string) 						 \"DOSY data\"\n")
   print("#Date (string) 							 \"07-Aug-2015 15:43:13\" \n")
   print("#DOSY Toolbox Format Version (string) 				 0.1 \n")
   print("#DOSY Toolbox Version (string) 					 \"DOSY Toolbox version 2.5\" \n")
   print("#Number Of Arrays (integer)					 1  \n")
   print("#Spectrometer/Data System (string)				 \"Magritek Spinsolve\"  \n")
   print("#Title (string) 						 \"DOSY FID\"\n")
   print("## ************ Matrix Format **********************************  \n")
   print("#Complex Data (string)						 \"Yes\" \n")
   print("#Number Of Rows (integer) 					 $nrSteps$  \n")
   print("#Points Per Row (integer) 					 $nrPnts$  \n")
   print("#Y Axis Definition (string)					 \"Gradient Amplitude\"  \n")
   print("#Y Label (null)						   \n")
   print("## ************ Acquisition Parameters *************************  \n")
   print("#Acquisition Time (double; s) 					 $nrPnts*dwellTime/1.0e6$  \n")
   print("#Complex Points Acquired (integer) 				 $nrPnts$  \n")
   print("#Lowest Frequency (double ; ppm)				 $single(-1000*bandwidth/b1Freq1H/2+ppmOffset)$  \n")
   print("#Observe Frequency (double ; MHz) 				 $single(b1Freq1H)$  \n")
   print("#Observe Nucleus (string) 					 \"1-H\"  \n")
   print("#Spectral Width (double ; ppm) 					 $single(1000*bandwidth/b1Freq1H)$  \n")
   print("#Pulse Sequence Name (string) 					 \"Unknown\"  \n")
   print("#Left Rotation (double)						 0.000000e+00  \n")
   print("## ************ Processing parameters ***************************  \n")
   print("#Fourier Number (integer) 					 $nrPnts*zf$  \n")
   print("#Left Phase (double; degree; First order) 			 0.000000e+00  \n")
   print("#Right Phase (double; degree; Zeroth order) 			 0.000000e+00  \n")
   print("#Left Phase Array [$nrSteps$] (double data 1 ; T m^-1)			 \n")
   for (iii = 1 to nrSteps)
      print("0.000000e+00\n")
   next(iii)
   print("#Right Phase Array [$nrSteps$] (double data 1 ; T m^-1)			 \n")
   for (iii = 1 to nrSteps)
      print("0.000000e+00\n")
   next(iii)
   print("## ************ Diffusion Parameters ****************************\n")
   print("#Diffusion Delay (double ; s ; DELTA) 				 $bDelta/1000$\n")
   print("#Diffusion Encoding Time (double ; s ; delta) 			 $lDeltaCorr/1000$\n")
   print("#Dosygamma (double) 						 2.675246e+08\n")
   print("#Dosytimecubed (double) 					 $lDeltaCorr*lDeltaCorr*(bDelta-lDeltaCorr/3)*1.0e-9$\n")
   print("#Gradient Shape (string) 					 \"Square\"\n")
   print("#Pulse Sequence Type (string)					 \"Other\" \n")
   print("#Tau (null)					   \n")
   print("## ************ Arrays *****************************************  \n")
   print("#Gradient Amplitude [$nrSteps$] (double data 1 ; T m^-1)			\n")
   for (iii = 0 to nrSteps-1)
   #   print("$sqrt(iii/nrSteps)*gradAmp$\n")
      gradValue   =  (sqrt(iii+0.2))*(gradAmp )/(sqrt(nrSteps-0.8))/1000
      print("$gradValue$\n")
   next(iii)
   print("## ************ Actual Data Points *****************************\n")
   print("#Data Points [$nrPnts*nrSteps$] (double)\n")
   closeprint()


# Restore cwd
   cd(bak)

endproc()

########################################################
# Save the gradient values to a file
########################################################

procedure(saveGradients, gradValue, guipar)

# Extract GUI parameters
   assignlist(guipar)

# Save data and plot in chosen folder
   bak = getcwd()

   cd(dataDirectory)
   cd(expName)
   if(isvar("expNr"))
      cd("$expNr$")
   endif

   printtofile("gradients.par")
   for (k = 0 to nrSteps-1)
      print("$gradValue[k]$\n")
   next(iii)
   closeprint()

endproc()
